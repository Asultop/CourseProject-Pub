# 代码详解 — 完全背包（AcWing 3）

## 功能概述
给定 N 件物品和容量 V，每件物品有体积 v[i] 和价值 w[i]，可重复选取物品（完全背包），求最大总价值。

## 原始代码（要点）
- 使用二维 DP：`f[i][j]` 表示前 i 件物品放入容量为 j 的背包所能取得的最大价值。
- 状态转移：
    - 若 j < v[i]：`f[i][j] = f[i-1][j]`
    - 否则：`f[i][j] = max(f[i-1][j], f[i][j - v[i]] + w[i])`
    其中 `f[i][j - v[i]]` 用的是同一层 i，表示可以再次选取第 i 件物品（完全背包特征）。
- 初始：`f[0][*] = 0`（代码中数组已初始化为 0）。
- 最终答案：`f[N][V]`。

## 变量说明
- N：物品数量
- V：背包容量
- v[i]：第 i 件物品体积（代码中 1-based）
- w[i]：第 i 件物品价值
- f[i][j]：DP 表，二维数组，大小约 (N+1) x (V+1)

## 正确性说明
转移 `f[i][j] = max(f[i-1][j], f[i][j-v[i]] + w[i])`：
- `f[i-1][j]` 表示不选第 i 件物品；
- `f[i][j-v[i]] + w[i]` 表示至少选一件第 i 件物品，剩余容量用同一 i 层继续决定，允许重复选择 —— 正是完全背包的标准转移。

## 复杂度
- 时间复杂度：O(N * V)
- 空间复杂度：O(N * V)（可优化为 O(V)）

## 优化（滚动数组到一维）
可以将二维 DP 压缩为一维数组 f[j]，对于完全背包，遍历物品时内层容量从小到大（递增）：
        for i in 1..N:
                for j in v[i]..V:    // 递增
                        f[j] = max(f[j], f[j - v[i]] + w[i])

一维实现示例（C）：
        #include <stdio.h>
        #define max(a,b) ((a)>(b)?(a):(b))
        int main(){
                int v[1008], w[1008];
                int f[1008] = {0};
                int N, V;
                if(scanf("%d%d",&N,&V)!=2) return 0;
                for(int i=1;i<=N;i++) scanf("%d%d",&v[i],&w[i]);
                for(int i=1;i<=N;i++){
                        for(int j=v[i]; j<=V; j++){
                                f[j] = max(f[j], f[j - v[i]] + w[i]);
                        }
                }
                printf("%d", f[V]);
                return 0;
        }

## 注意事项
- 原代码使用 1-based 索引，确保输入匹配。
- 若 N 和 V 较大（例如 1000+），二维数组可能占用较多内存，推荐使用一维优化。